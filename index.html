<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>〔特〕抽出ツール（ファイル選択のみ）</title>
<style>
  :root{--pri:#1668c7;--mut:#666;--err:#d22}
  body{font-family:system-ui,-apple-system,"Segoe UI","Noto Sans JP",sans-serif;line-height:1.6;margin:0}
  header{padding:16px 20px;background:linear-gradient(90deg,var(--pri),#1e90ff);color:#fff}
  header h1{margin:0 0 6px;font-size:20px}
  header .sub{opacity:.9;font-size:12px}
  main{padding:16px 20px}
  .panel{border:1px solid #e5e7eb;border-radius:10px;padding:14px;margin:14px 0;background:#fff}
  .flex{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  label{display:flex;gap:6px;align-items:center}
  input[type="file"]{padding:6px}
  select,button{padding:8px 12px;border-radius:8px;border:1px solid #cfd6e0;background:#fff}
  button.primary{background:#1668c7;color:#fff;border-color:#1668c7}
  button:disabled{opacity:.6}
  table{border-collapse:collapse;width:100%;font-size:14px}
  th,td{border:1px solid #e5e7eb;padding:8px;vertical-align:top}
  th{background:#fafafa;position:sticky;top:0}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;background:#eef;color:#225}
  .mut{color:var(--mut)} .err{color:var(--err)}
  progress{width:240px;height:12px}
  footer{padding:16px 20px;color:#666;font-size:12px}
  details summary{cursor:pointer}
  .filelist{margin:6px 0 0 0;padding-left:18px;font-size:13px}
  #log{white-space:pre-wrap;font-size:12px;color:#333;background:#fafafa;border:1px solid #eee;padding:8px;border-radius:6px;max-height:180px;overflow:auto}
  .ok{color:#0a8} .ng{color:#d22}
</style>
</head>
<body>
<header>
  <h1>〔特〕抽出ツール（ファイル選択のみ）</h1>
  <div class="sub">PDF一括処理／〔特〕枠抽出／CSV・Excel出力／日本語OCR（必要時のみ）— すべてブラウザ内</div>
</header>

<main>
  <section class="panel">
    <div class="flex">
      <input type="file" id="fileInput" accept="application/pdf" multiple />
      <button id="btnStart" class="primary" disabled>抽出開始</button>
      <button id="btnExportCsv" disabled>CSVダウンロード</button>
      <button id="btnExportXlsx" disabled>Excelダウンロード</button>
      <span id="runStatus" class="badge">待機中</span>
    </div>
    <div class="flex" style="margin-top:8px">
      <label><input type="checkbox" id="includeTimeline" /> タイムライン欄の「[特]」も含める</label>
      <label><input type="checkbox" id="strictTokki" checked /> 〔特〕枠のみ厳格抽出（^HH:MM [特]）</label>
      <label>OCRモード：
        <select id="ocrMode">
          <option value="off">しない</option>
          <option value="auto" selected>必要時のみ</option>
          <option value="always">常に</option>
        </select>
      </label>
      <label>OCR解像度：
        <select id="ocrScale">
          <option value="1.5">1.5x（速い）</option>
          <option value="2.0" selected>2.0x</option>
          <option value="3.0">3.0x（精度）</option>
        </select>
      </label>
    </div>
    <div id="selectedInfo" class="mut" style="margin-top:6px">未選択</div>
    <ul id="fileList" class="filelist"></ul>
    <div class="flex" style="margin-top:6px">
      <progress id="progress" max="100" value="0"></progress>
      <span id="progressText" class="mut">0%</span>
    </div>
    <div id="stats" style="margin-top:8px" class="mut"></div>
  </section>

  <section class="panel">
    <table id="resultTable">
      <thead><tr><th>ファイル名</th><th>ページ</th><th>氏名</th><th>〔特〕枠の内容</th></tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <section class="panel">
    <details open>
      <summary>診断・ログ</summary>
      <div id="diag"></div>
      <div id="error" class="err"></div>
      <div id="log"></div>
    </details>
  </section>
</main>

<footer>© 2025 〔特〕抽出ツール（クライアントサイド版）</footer>

<!-- ライブラリ（フォールバック付き） -->
<script>
(async () => {
  const diag = (msg, ok=true) => {
    const el = document.getElementById('diag');
    const line = document.createElement('div');
    line.innerHTML = ok ? `<span class="ok">OK</span> ${msg}` : `<span class="ng">NG</span> ${msg}`;
    el.appendChild(line);
  };
  const loadScript = (src) => new Promise((resolve, reject) => {
    const s = document.createElement('script'); s.src = src; s.async = true;
    s.onload = () => resolve(src); s.onerror = () => reject(new Error('Load failed: '+src));
    document.head.appendChild(s);
  });
  const tryLoad = async (cands, test) => {
    for (const url of cands) {
      try { await loadScript(url); if (test()) { diag(`Loaded: ${url}`); return url; } }
      catch { diag(`Failed: ${url}`, false); }
    }
    throw new Error('All CDN candidates failed.');
  };

  // pdf.js
  const pdfBase = [
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/',
    'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/',
    'https://unpkg.com/pdfjs-dist@3.11.174/build/'
  ];
  const used = await tryLoad(pdfBase.map(b => b+'pdf.min.js'), () => !!window.pdfjsLib);
  const worker = used.replace('pdf.min.js', 'pdf.worker.min.js');
  window.pdfjsLib.GlobalWorkerOptions.workerSrc = worker;
  diag('pdf.js: OK');

  // xlsx
  await tryLoad([
    'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js',
    'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js'
  ], () => !!window.XLSX);
  diag('xlsx: OK');

  // tesseract.js
  try {
    await tryLoad([
      'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js',
      'https://unpkg.com/tesseract.js@5/dist/tesseract.min.js'
    ], () => !!window.Tesseract);
    diag('tesseract.js: OK（OCRは必要時のみ使用）');
  } catch {
    diag('tesseract.js: 読み込み失敗（OCR off/autoなら続行可）', false);
  }

  // ===== メイン =====
  document.addEventListener('DOMContentLoaded', () => {
    const el = {
      fileInput: document.getElementById('fileInput'),
      btnStart: document.getElementById('btnStart'),
      btnExportCsv: document.getElementById('btnExportCsv'),
      btnExportXlsx: document.getElementById('btnExportXlsx'),
      includeTimeline: document.getElementById('includeTimeline'),
      strictTokki: document.getElementById('strictTokki'),
      ocrMode: document.getElementById('ocrMode'),
      ocrScale: document.getElementById('ocrScale'),
      selectedInfo: document.getElementById('selectedInfo'),
      fileList: document.getElementById('fileList'),
      progress: document.getElementById('progress'),
      progressText: document.getElementById('progressText'),
      stats: document.getElementById('stats'),
      runStatus: document.getElementById('runStatus'),
      tbody: document.querySelector('#resultTable tbody'),
      error: document.getElementById('error'),
      log: document.getElementById('log'),
    };
    const log = (m) => { el.log.textContent += (el.log.textContent ? "\n" : "") + m; };
    const setError = (msg) => { el.error.textContent = msg || ""; if(msg) console.error(msg); };
    const status = (t) => el.runStatus.textContent = t;
    const setProgress = (v, t='') => { el.progress.value = v; el.progressText.textContent = `${v|0}% ${t}`; };
    const normSpace = s => (s||'').replace(/\u3000/g,' ').replace(/[ \t\r]+/g,' ').trim();

    const results = []; let selectedFiles = [];

    function setStats({files=0,pages=0,hits=0,misses=0}){
      el.stats.textContent = `処理ファイル数: ${files} / 総ページ: ${pages} / ヒット: ${hits} / 未検出: ${misses}`;
    }
    function clearRows(){ el.tbody.innerHTML = ''; }
    function addRow({file,page,name,tokki}){
      const tr = document.createElement('tr');
      const td = (t) => { const x=document.createElement('td'); x.innerHTML=t; return x; };
      tr.append(td(file), td(page), td(name),
               td(tokki.map(l=>`<div>${l.replace(/</g,'&lt;')}</div>`).join('')));
      el.tbody.appendChild(tr);
    }

    function extractNameFromText(text){
      let m = text.replace(/\s+/g,' ').match(/ご利用者名\s*([\p{sc=Hani}\p{sc=Hira}\p{sc=Kana}ー・\s]+?)\s+来所日時/iu);
      if (!m) m = text.replace(/\s+/g,' ').match(/ご利用者名\s*([^\s]+(?:\s+[^\s]+)?)\s+来所日時/);
      return m ? m[1].trim() : '';
    }
    function linesFromTextContent(tc){
      const items = tc.items || []; const lines = []; let cur = [];
      for(const it of items){ cur.push(it.str); if(it.hasEOL){ lines.push(cur.join('')); cur=[]; } }
      if(cur.length) lines.push(cur.join(''));
      return lines.map(l=>l.replace(/[ \t]+/g,' ').trim()).filter(Boolean);
    }
    function extractTokkiLines(lines, {includeTimeline=false, strict=true}){
      const reFrame = /^(\d{2}:\d{2})\s*[\[\(（]?特[\]\)）]?\s*(.+)$/u;
      const out = [];
      for(let i=0;i<lines.length;i++){
        const line = lines[i].trim();
        if(strict){
          const m = line.match(reFrame);
          if(m){
            let content = m[2]; let j = i+1;
            while(j<lines.length && !/^\d{2}:\d{2}\b/.test(lines[j]) && !/^\s*$/.test(lines[j])){
              content += ' ' + lines[j].trim(); j++;
            }
            i = j-1;
            out.push(`${m[1]} ${normSpace(content)}`);
          }
        }else{
          if(/特/.test(line)) out.push(line);
        }
      }
      if(includeTimeline && strict){
        for(const l of lines){ if(/\[?特\]?/.test(l) && !out.includes(l)) out.push(l); }
      }
      return out;
    }
    async function ocrPageToText(page, scale=2.0){
      try{
        const viewport = page.getViewport({ scale: Number(scale) });
        const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
        canvas.width = Math.ceil(viewport.width); canvas.height = Math.ceil(viewport.height);
        await page.render({ canvasContext: ctx, viewport }).promise;
        if(!window.Tesseract) throw new Error('Tesseract.js not loaded');
        const worker = await Tesseract.createWorker({ langPath: 'https://tessdata.projectnaptha.com/4.0.0' });
        try{ await worker.loadLanguage('jpn+eng'); await worker.initialize('jpn+eng');
             const { data:{ text } } = await worker.recognize(canvas.toDataURL('image/png')); return text||''; }
        finally{ await worker.terminate(); }
      }catch(e){ log('OCR失敗: '+e.message); return ''; }
    }

    async function processFiles(fileList){
      setError(''); status('解析中…'); setProgress(0); setStats({}); clearRows(); results.length = 0;
      el.btnStart.disabled = true; el.btnExportCsv.disabled = true; el.btnExportXlsx.disabled = true;

      const useOCR = el.ocrMode.value, ocrScale = el.ocrScale.value;
      const strict = el.strictTokki.checked, includeTimeline = el.includeTimeline.checked;

      let totalPages = 0, donePages = 0, hitCount = 0, missCount = 0;

      for(const file of fileList){
        let pdf;
        try{ const ab = await file.arrayBuffer(); pdf = await pdfjsLib.getDocument({ data: ab }).promise; }
        catch(e){ setError('PDFの読み込みに失敗（CDN/ネットワーク/ファイル破損の可能性）'); log(String(e)); continue; }
        totalPages += pdf.numPages;

        for(let p=1;p<=pdf.numPages;p++){
          try{
            const page = await pdf.getPage(p);
            let lines = [], text = '';
            try{ const tc = await page.getTextContent({ normalizeWhitespace:false, disableCombineTextItems:false });
                 lines = linesFromTextContent(tc); text = lines.join('\n'); } catch{}

            const needOCR = (useOCR==='always') || (useOCR==='auto' && (!lines || lines.length===0));
            if(needOCR){ text = await ocrPageToText(page, ocrScale); lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean); }

            const name = extractNameFromText(text);
            const tokki = extractTokkiLines(lines, { includeTimeline, strict });

            if(tokki.length>0){ results.push({ file: file.name, page: p, name, tokki }); addRow({ file: file.name, page: p, name, tokki }); hitCount++; }
            else { missCount++; }
          }catch(e){ log(`ページ処理エラー p.${p}: `+e.message); }
          finally { donePages++; setProgress(donePages/totalPages*100, `${donePages}/${totalPages}p`); }
        }
      }
      setStats({ files: fileList.length, pages: totalPages, hits: hitCount, misses: missCount });
      el.btnExportCsv.disabled = results.length===0; el.btnExportXlsx.disabled = results.length===0;
      status('完了'); el.btnStart.disabled = selectedFiles.length === 0;

      // export
      function toCSV(rows){ const esc=v=>'"'+String(v??'').replace(/"/g,'""').replace(/\r?\n/g,'\\n')+'"';
        const header=['ファイル名','ページ','氏名','〔特〕枠の内容'];
        const body=rows.map(r=>[r.file,r.page,r.name,r.tokki.join('\n')].map(esc).join(','));
        return [header.join(','),...body].join('\n'); }
      function downloadBlob(blob,name){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0); }
      el.btnExportCsv.onclick = ()=>{ const csv=toCSV(results); const ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,''); downloadBlob(new Blob([csv],{type:'text/csv;charset=utf-8;'}),`tokki_extract_${ts}.csv`); };
      el.btnExportXlsx.onclick = ()=>{ const rows=results.map(r=>({'ファイル名':r.file,'ページ':r.page,'氏名':r.name,'〔特〕枠の内容':r.tokki.join('\n')})); const ws=XLSX.utils.json_to_sheet(rows); const wb=XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb,ws,'〔特〕あり'); const buf=XLSX.write(wb,{bookType:'xlsx',type:'array'}); const ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,''); downloadBlob(new Blob([buf],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}),`tokki_extract_${ts}.xlsx`); };
    }

    // ファイル選択のみ（ドロップなし）
    function renderFileList(files){
      el.fileList.innerHTML=''; if(!files || files.length===0){ el.selectedInfo.textContent='未選択'; el.btnStart.disabled=true; return; }
      el.selectedInfo.textContent=`選択済み: ${files.length} ファイル（抽出開始を押してください）`;
      const frag=document.createDocumentFragment();
      Array.from(files).forEach(f=>{ const li=document.createElement('li'); li.textContent=f.name; frag.appendChild(li); });
      el.fileList.appendChild(frag);
      el.btnStart.disabled=false; status('準備完了'); setProgress(0,''); setStats({files:files.length}); el.tbody.innerHTML=''; el.btnExportCsv.disabled=true; el.btnExportXlsx.disabled=true;
    }
    el.fileInput.addEventListener('change', e => {
      if(e.target.files?.length){ selectedFiles = Array.from(e.target.files); renderFileList(selectedFiles); }
    });
    el.btnStart.addEventListener('click', ()=>{ if(selectedFiles?.length){ processFiles(selectedFiles); } });

    // グローバルエラー
    window.addEventListener('error', ev => setError(`スクリプトエラー: ${ev.message}`));
    window.addEventListener('unhandledrejection', ev => setError(`未処理のPromise拒否: ${ev.reason}`));
  });
})();
</script>
</body>
</html><!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>〔特〕抽出ツール（ファイル選択のみ）</title>
<style>
  :root{--pri:#1668c7;--mut:#666;--err:#d22}
  body{font-family:system-ui,-apple-system,"Segoe UI","Noto Sans JP",sans-serif;line-height:1.6;margin:0}
  header{padding:16px 20px;background:linear-gradient(90deg,var(--pri),#1e90ff);color:#fff}
  header h1{margin:0 0 6px;font-size:20px}
  header .sub{opacity:.9;font-size:12px}
  main{padding:16px 20px}
  .panel{border:1px solid #e5e7eb;border-radius:10px;padding:14px;margin:14px 0;background:#fff}
  .flex{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  label{display:flex;gap:6px;align-items:center}
  input[type="file"]{padding:6px}
  select,button{padding:8px 12px;border-radius:8px;border:1px solid #cfd6e0;background:#fff}
  button.primary{background:#1668c7;color:#fff;border-color:#1668c7}
  button:disabled{opacity:.6}
  table{border-collapse:collapse;width:100%;font-size:14px}
  th,td{border:1px solid #e5e7eb;padding:8px;vertical-align:top}
  th{background:#fafafa;position:sticky;top:0}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;background:#eef;color:#225}
  .mut{color:var(--mut)} .err{color:var(--err)}
  progress{width:240px;height:12px}
  footer{padding:16px 20px;color:#666;font-size:12px}
  details summary{cursor:pointer}
  .filelist{margin:6px 0 0 0;padding-left:18px;font-size:13px}
  #log{white-space:pre-wrap;font-size:12px;color:#333;background:#fafafa;border:1px solid #eee;padding:8px;border-radius:6px;max-height:180px;overflow:auto}
  .ok{color:#0a8} .ng{color:#d22}
</style>
</head>
<body>
<header>
  <h1>〔特〕抽出ツール（ファイル選択のみ）</h1>
  <div class="sub">PDF一括処理／〔特〕枠抽出／CSV・Excel出力／日本語OCR（必要時のみ）— すべてブラウザ内</div>
</header>

<main>
  <section class="panel">
    <div class="flex">
      <input type="file" id="fileInput" accept="application/pdf" multiple />
      <button id="btnStart" class="primary" disabled>抽出開始</button>
      <button id="btnExportCsv" disabled>CSVダウンロード</button>
      <button id="btnExportXlsx" disabled>Excelダウンロード</button>
      <span id="runStatus" class="badge">待機中</span>
    </div>
    <div class="flex" style="margin-top:8px">
      <label><input type="checkbox" id="includeTimeline" /> タイムライン欄の「[特]」も含める</label>
      <label><input type="checkbox" id="strictTokki" checked /> 〔特〕枠のみ厳格抽出（^HH:MM [特]）</label>
      <label>OCRモード：
        <select id="ocrMode">
          <option value="off">しない</option>
          <option value="auto" selected>必要時のみ</option>
          <option value="always">常に</option>
        </select>
      </label>
      <label>OCR解像度：
        <select id="ocrScale">
          <option value="1.5">1.5x（速い）</option>
          <option value="2.0" selected>2.0x</option>
          <option value="3.0">3.0x（精度）</option>
        </select>
      </label>
    </div>
    <div id="selectedInfo" class="mut" style="margin-top:6px">未選択</div>
    <ul id="fileList" class="filelist"></ul>
    <div class="flex" style="margin-top:6px">
      <progress id="progress" max="100" value="0"></progress>
      <span id="progressText" class="mut">0%</span>
    </div>
    <div id="stats" style="margin-top:8px" class="mut"></div>
  </section>

  <section class="panel">
    <table id="resultTable">
      <thead><tr><th>ファイル名</th><th>ページ</th><th>氏名</th><th>〔特〕枠の内容</th></tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <section class="panel">
    <details open>
      <summary>診断・ログ</summary>
      <div id="diag"></div>
      <div id="error" class="err"></div>
      <div id="log"></div>
    </details>
  </section>
</main>

<footer>© 2025 〔特〕抽出ツール（クライアントサイド版）</footer>

<!-- ライブラリ（フォールバック付き） -->
<script>
(async () => {
  const diag = (msg, ok=true) => {
    const el = document.getElementById('diag');
    const line = document.createElement('div');
    line.innerHTML = ok ? `<span class="ok">OK</span> ${msg}` : `<span class="ng">NG</span> ${msg}`;
    el.appendChild(line);
  };
  const loadScript = (src) => new Promise((resolve, reject) => {
    const s = document.createElement('script'); s.src = src; s.async = true;
    s.onload = () => resolve(src); s.onerror = () => reject(new Error('Load failed: '+src));
    document.head.appendChild(s);
  });
  const tryLoad = async (cands, test) => {
    for (const url of cands) {
      try { await loadScript(url); if (test()) { diag(`Loaded: ${url}`); return url; } }
      catch { diag(`Failed: ${url}`, false); }
    }
    throw new Error('All CDN candidates failed.');
  };

  // pdf.js
  const pdfBase = [
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/',
    'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/',
    'https://unpkg.com/pdfjs-dist@3.11.174/build/'
  ];
  const used = await tryLoad(pdfBase.map(b => b+'pdf.min.js'), () => !!window.pdfjsLib);
  const worker = used.replace('pdf.min.js', 'pdf.worker.min.js');
  window.pdfjsLib.GlobalWorkerOptions.workerSrc = worker;
  diag('pdf.js: OK');

  // xlsx
  await tryLoad([
    'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js',
    'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js'
  ], () => !!window.XLSX);
  diag('xlsx: OK');

  // tesseract.js
  try {
    await tryLoad([
      'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js',
      'https://unpkg.com/tesseract.js@5/dist/tesseract.min.js'
    ], () => !!window.Tesseract);
    diag('tesseract.js: OK（OCRは必要時のみ使用）');
  } catch {
    diag('tesseract.js: 読み込み失敗（OCR off/autoなら続行可）', false);
  }

  // ===== メイン =====
  document.addEventListener('DOMContentLoaded', () => {
    const el = {
      fileInput: document.getElementById('fileInput'),
      btnStart: document.getElementById('btnStart'),
      btnExportCsv: document.getElementById('btnExportCsv'),
      btnExportXlsx: document.getElementById('btnExportXlsx'),
      includeTimeline: document.getElementById('includeTimeline'),
      strictTokki: document.getElementById('strictTokki'),
      ocrMode: document.getElementById('ocrMode'),
      ocrScale: document.getElementById('ocrScale'),
      selectedInfo: document.getElementById('selectedInfo'),
      fileList: document.getElementById('fileList'),
      progress: document.getElementById('progress'),
      progressText: document.getElementById('progressText'),
      stats: document.getElementById('stats'),
      runStatus: document.getElementById('runStatus'),
      tbody: document.querySelector('#resultTable tbody'),
      error: document.getElementById('error'),
      log: document.getElementById('log'),
    };
    const log = (m) => { el.log.textContent += (el.log.textContent ? "\n" : "") + m; };
    const setError = (msg) => { el.error.textContent = msg || ""; if(msg) console.error(msg); };
    const status = (t) => el.runStatus.textContent = t;
    const setProgress = (v, t='') => { el.progress.value = v; el.progressText.textContent = `${v|0}% ${t}`; };
    const normSpace = s => (s||'').replace(/\u3000/g,' ').replace(/[ \t\r]+/g,' ').trim();

    const results = []; let selectedFiles = [];

    function setStats({files=0,pages=0,hits=0,misses=0}){
      el.stats.textContent = `処理ファイル数: ${files} / 総ページ: ${pages} / ヒット: ${hits} / 未検出: ${misses}`;
    }
    function clearRows(){ el.tbody.innerHTML = ''; }
    function addRow({file,page,name,tokki}){
      const tr = document.createElement('tr');
      const td = (t) => { const x=document.createElement('td'); x.innerHTML=t; return x; };
      tr.append(td(file), td(page), td(name),
               td(tokki.map(l=>`<div>${l.replace(/</g,'&lt;')}</div>`).join('')));
      el.tbody.appendChild(tr);
    }

    function extractNameFromText(text){
      let m = text.replace(/\s+/g,' ').match(/ご利用者名\s*([\p{sc=Hani}\p{sc=Hira}\p{sc=Kana}ー・\s]+?)\s+来所日時/iu);
      if (!m) m = text.replace(/\s+/g,' ').match(/ご利用者名\s*([^\s]+(?:\s+[^\s]+)?)\s+来所日時/);
      return m ? m[1].trim() : '';
    }
    function linesFromTextContent(tc){
      const items = tc.items || []; const lines = []; let cur = [];
      for(const it of items){ cur.push(it.str); if(it.hasEOL){ lines.push(cur.join('')); cur=[]; } }
      if(cur.length) lines.push(cur.join(''));
      return lines.map(l=>l.replace(/[ \t]+/g,' ').trim()).filter(Boolean);
    }
    function extractTokkiLines(lines, {includeTimeline=false, strict=true}){
      const reFrame = /^(\d{2}:\d{2})\s*[\[\(（]?特[\]\)）]?\s*(.+)$/u;
      const out = [];
      for(let i=0;i<lines.length;i++){
        const line = lines[i].trim();
        if(strict){
          const m = line.match(reFrame);
          if(m){
            let content = m[2]; let j = i+1;
            while(j<lines.length && !/^\d{2}:\d{2}\b/.test(lines[j]) && !/^\s*$/.test(lines[j])){
              content += ' ' + lines[j].trim(); j++;
            }
            i = j-1;
            out.push(`${m[1]} ${normSpace(content)}`);
          }
        }else{
          if(/特/.test(line)) out.push(line);
        }
      }
      if(includeTimeline && strict){
        for(const l of lines){ if(/\[?特\]?/.test(l) && !out.includes(l)) out.push(l); }
      }
      return out;
    }
    async function ocrPageToText(page, scale=2.0){
      try{
        const viewport = page.getViewport({ scale: Number(scale) });
        const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
        canvas.width = Math.ceil(viewport.width); canvas.height = Math.ceil(viewport.height);
        await page.render({ canvasContext: ctx, viewport }).promise;
        if(!window.Tesseract) throw new Error('Tesseract.js not loaded');
        const worker = await Tesseract.createWorker({ langPath: 'https://tessdata.projectnaptha.com/4.0.0' });
        try{ await worker.loadLanguage('jpn+eng'); await worker.initialize('jpn+eng');
             const { data:{ text } } = await worker.recognize(canvas.toDataURL('image/png')); return text||''; }
        finally{ await worker.terminate(); }
      }catch(e){ log('OCR失敗: '+e.message); return ''; }
    }

    async function processFiles(fileList){
      setError(''); status('解析中…'); setProgress(0); setStats({}); clearRows(); results.length = 0;
      el.btnStart.disabled = true; el.btnExportCsv.disabled = true; el.btnExportXlsx.disabled = true;

      const useOCR = el.ocrMode.value, ocrScale = el.ocrScale.value;
      const strict = el.strictTokki.checked, includeTimeline = el.includeTimeline.checked;

      let totalPages = 0, donePages = 0, hitCount = 0, missCount = 0;

      for(const file of fileList){
        let pdf;
        try{ const ab = await file.arrayBuffer(); pdf = await pdfjsLib.getDocument({ data: ab }).promise; }
        catch(e){ setError('PDFの読み込みに失敗（CDN/ネットワーク/ファイル破損の可能性）'); log(String(e)); continue; }
        totalPages += pdf.numPages;

        for(let p=1;p<=pdf.numPages;p++){
          try{
            const page = await pdf.getPage(p);
            let lines = [], text = '';
            try{ const tc = await page.getTextContent({ normalizeWhitespace:false, disableCombineTextItems:false });
                 lines = linesFromTextContent(tc); text = lines.join('\n'); } catch{}

            const needOCR = (useOCR==='always') || (useOCR==='auto' && (!lines || lines.length===0));
            if(needOCR){ text = await ocrPageToText(page, ocrScale); lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean); }

            const name = extractNameFromText(text);
            const tokki = extractTokkiLines(lines, { includeTimeline, strict });

            if(tokki.length>0){ results.push({ file: file.name, page: p, name, tokki }); addRow({ file: file.name, page: p, name, tokki }); hitCount++; }
            else { missCount++; }
          }catch(e){ log(`ページ処理エラー p.${p}: `+e.message); }
          finally { donePages++; setProgress(donePages/totalPages*100, `${donePages}/${totalPages}p`); }
        }
      }
      setStats({ files: fileList.length, pages: totalPages, hits: hitCount, misses: missCount });
      el.btnExportCsv.disabled = results.length===0; el.btnExportXlsx.disabled = results.length===0;
      status('完了'); el.btnStart.disabled = selectedFiles.length === 0;

      // export
      function toCSV(rows){ const esc=v=>'"'+String(v??'').replace(/"/g,'""').replace(/\r?\n/g,'\\n')+'"';
        const header=['ファイル名','ページ','氏名','〔特〕枠の内容'];
        const body=rows.map(r=>[r.file,r.page,r.name,r.tokki.join('\n')].map(esc).join(','));
        return [header.join(','),...body].join('\n'); }
      function downloadBlob(blob,name){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0); }
      el.btnExportCsv.onclick = ()=>{ const csv=toCSV(results); const ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,''); downloadBlob(new Blob([csv],{type:'text/csv;charset=utf-8;'}),`tokki_extract_${ts}.csv`); };
      el.btnExportXlsx.onclick = ()=>{ const rows=results.map(r=>({'ファイル名':r.file,'ページ':r.page,'氏名':r.name,'〔特〕枠の内容':r.tokki.join('\n')})); const ws=XLSX.utils.json_to_sheet(rows); const wb=XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb,ws,'〔特〕あり'); const buf=XLSX.write(wb,{bookType:'xlsx',type:'array'}); const ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,''); downloadBlob(new Blob([buf],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}),`tokki_extract_${ts}.xlsx`); };
    }

    // ファイル選択のみ（ドロップなし）
    function renderFileList(files){
      el.fileList.innerHTML=''; if(!files || files.length===0){ el.selectedInfo.textContent='未選択'; el.btnStart.disabled=true; return; }
      el.selectedInfo.textContent=`選択済み: ${files.length} ファイル（抽出開始を押してください）`;
      const frag=document.createDocumentFragment();
      Array.from(files).forEach(f=>{ const li=document.createElement('li'); li.textContent=f.name; frag.appendChild(li); });
      el.fileList.appendChild(frag);
      el.btnStart.disabled=false; status('準備完了'); setProgress(0,''); setStats({files:files.length}); el.tbody.innerHTML=''; el.btnExportCsv.disabled=true; el.btnExportXlsx.disabled=true;
    }
    el.fileInput.addEventListener('change', e => {
      if(e.target.files?.length){ selectedFiles = Array.from(e.target.files); renderFileList(selectedFiles); }
    });
    el.btnStart.addEventListener('click', ()=>{ if(selectedFiles?.length){ processFiles(selectedFiles); } });

    // グローバルエラー
    window.addEventListener('error', ev => setError(`スクリプトエラー: ${ev.message}`));
    window.addEventListener('unhandledrejection', ev => setError(`未処理のPromise拒否: ${ev.reason}`));
  });
})();
</script>
</body>
</html>
